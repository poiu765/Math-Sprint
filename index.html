<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>수능 기초 체력 훈련</title>
  <style>
    :root{
      --bg:#ffffff;
      --fg:#111111;
      --muted:#6b7280;
      --line:#e5e7eb;
      --accent:#111111;
      --danger:#b91c1c;
      --ok:#047857;
      --card:#fafafa;
      --btn:#111111;
      --btnfg:#ffffff;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      line-height:1.35;
    }
    .wrap{ max-width:980px; margin:0 auto; padding:20px; }
    h1{ margin:0 0 12px; font-size:20px; }
    .grid{
      display:grid; gap:12px;
      grid-template-columns: 1fr;
    }
    @media (min-width: 900px){
      .grid{ grid-template-columns: 1.1fr 0.9fr; }
    }
    .card{
      border:1px solid var(--line);
      background:var(--card);
      border-radius:12px;
      padding:14px;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label{ font-size:13px; color:var(--muted); }
    select, input[type="number"], input[type="text"]{
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:10px;
      background:#fff;
      font-size:16px;
      outline:none;
    }
    select:focus, input:focus{ border-color:#c7c7c7; }
    .btn{
      padding:10px 14px;
      border:1px solid var(--btn);
      background:var(--btn);
      color:var(--btnfg);
      border-radius:10px;
      font-size:15px;
      cursor:pointer;
    }
    .btn.secondary{
      background:#fff; color:var(--fg); border-color:var(--line);
    }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .meta{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
      margin-top:10px;
    }
    .pill{
      border:1px solid var(--line);
      border-radius:10px;
      padding:10px 12px;
      background:#fff;
    }
    .pill .k{ font-size:12px; color:var(--muted); }
    .pill .v{ font-size:18px; font-weight:700; margin-top:2px; }
    .problem{
      display:flex; align-items:center; justify-content:center;
      background:#fff;
      border:1px solid var(--line);
      border-radius:14px;
      padding:18px;
      min-height:84px;
      font-size:34px;
      font-weight:800;
      letter-spacing:.5px;
      user-select:none;
    }
    .problem .btn{
      font-size:20px;
      padding:12px 20px;
      border-radius:12px;
    }
    .timerbar{
      margin-top:2px;
      height:12px;
      border:1px solid var(--line);
      border-radius:999px;
      background:#f3f4f6;
      overflow:hidden;
    }
    .timerbar.off{
      opacity:.45;
    }
    .timerbar-fill{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, #22c55e, #84cc16);
      transition:width .12s linear, background .18s ease;
    }
    .timerbar-fill.warn{
      background:#f59e0b;
    }
    .timerbar-fill.danger{
      background:#ef4444;
    }
    .answerRow{
      display:flex; gap:10px; margin-top:10px; align-items:stretch;
    }
    .answerRow input{
      flex:1;
      font-size:22px;
      padding:14px 14px;
      border-radius:14px;
    }
    .status{
      margin-top:10px; min-height:22px;
      font-size:14px; color:var(--muted);
    }
    .status.ok{ color:var(--ok); font-weight:700; }
    .status.bad{ color:var(--danger); font-weight:700; }
    .kbd{
      margin-top:12px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:10px;
    }
    .kbtn{
      padding:18px 0;
      border-radius:14px;
      border:1px solid var(--line);
      background:#fff;
      font-size:22px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
    }
    .kbtn:active{ transform: translateY(1px); }
    .kbtn.wide{ grid-column: span 2; }
    .kbtn.action{
      background:var(--btn); color:var(--btnfg); border-color:var(--btn);
    }
    .kbtn.danger{
      background:#fff; color:var(--danger); border-color:#f3c5c5;
    }
    .choices{
      margin-top:10px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:10px;
    }
    .choice-btn{
      padding:12px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#fff;
      font-size:16px;
      font-weight:700;
      cursor:pointer;
      user-select:none;
    }
    .choice-btn:active{ transform: translateY(1px); }
    .frac{
      display:inline-flex;
      flex-direction:column;
      align-items:center;
      line-height:1;
      vertical-align:middle;
      margin:0 2px;
    }
    .frac .top{
      border-bottom:1px solid currentColor;
      padding:0 2px 2px;
      font-size:0.95em;
    }
    .frac .bottom{
      padding:2px 2px 0;
      font-size:0.95em;
    }
    .help{ font-size:12px; color:var(--muted); margin-top:8px; }
    .brand{
      display:flex; align-items:center; gap:10px;
    }
    .brand img{
      height:32px; width:auto; display:block;
    }
    .hr{ height:1px; background:var(--line); margin:12px 0; }
    .small{ font-size:12px; color:var(--muted); }
    .toggle{
      display:flex; gap:8px; align-items:center;
      padding:8px 10px; border:1px solid var(--line);
      border-radius:10px; background:#fff;
    }
    input[type="checkbox"]{ width:18px; height:18px; }
    .auth-note{
      font-size:12px; color:var(--muted);
    }
    .lock-note{
      margin-top:8px; font-size:12px; color:var(--danger);
      font-weight:700;
    }
    .site-footer{
      margin-top:14px;
      text-align:right;
      font-size:11px;
      color:var(--muted);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div class="brand">
        <img src="logo.png" alt="로고" />
        <h1 style="margin:0;">수학 기초 훈련</h1>
      </div>
      <a href="stats.html" class="btn secondary">약점 확인</a>
    </div>

    <div class="card" id="authCard">
      <div style="font-weight:800; margin-bottom:6px;">로그인</div>
      <div class="row" style="margin-top:10px;">
        <button id="googleLoginBtn" class="btn">Google로 로그인</button>
        <button id="logoutBtn" class="btn secondary" disabled>로그아웃</button>
        <div class="auth-note" id="authStatus">로그인하지 않으면 게임을 사용할 수 없습니다.</div>
      </div>
      <div class="auth-note">※ Google 계정으로 로그인합니다.</div>
    </div>

    <div class="grid">
      <!-- LEFT: GAME -->
      <div class="card" id="gameCard">
        <div class="row">
          <div style="flex:1; min-width:220px;">
            <label>기초</label><br/>
            <select id="opSelect">
              <option value="add">덧셈</option>
              <option value="sub">뺄셈</option>
              <option value="mul">곱셈</option>
              <option value="div">나눗셈</option>
              <option value="trig">삼각함수</option>
            </select>
          </div>

          <div style="flex:1; min-width:220px;">
            <label>난이도 단계</label><br/>
            <select id="levelSelect"></select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div class="toggle">
            <input id="usePerQ" type="checkbox" checked />
            <label for="usePerQ" style="margin:0;color:var(--fg);">문제당 제한시간(초)</label>
            <input id="perQSec" type="number" min="0.5" max="30" step="0.1" value="5" style="width:90px;" />
          </div>

          <div class="toggle">
            <input id="useSet" type="checkbox" checked />
            <label for="useSet" style="margin:0;color:var(--fg);">세트 제한시간(초)</label>
            <input id="setSec" type="number" min="10" max="600" value="30" style="width:110px;" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="startBtn" class="btn">시작</button>
          <button id="stopBtn" class="btn secondary" disabled>중지</button>
          <span class="small">PC: Enter 제출 / Backspace 삭제</span>
        </div>

        <div class="meta">
          <div class="pill">
            <div class="k">세트 남은 시간</div>
            <div class="v">
              <div class="timerbar" id="setTimerBarWrap" aria-hidden="true">
                <div class="timerbar-fill" id="setTimerBarFill"></div>
              </div>
            </div>
          </div>
          <div class="pill">
            <div class="k">문제 남은 시간</div>
            <div class="v">
              <div class="timerbar" id="qTimerBarWrap" aria-hidden="true">
                <div class="timerbar-fill" id="qTimerBarFill"></div>
              </div>
            </div>
          </div>
          <div class="pill">
            <div class="k">정답</div>
            <div class="v"><span id="okCnt">0</span></div>
          </div>
          <div class="pill">
            <div class="k">오답/시간초과</div>
            <div class="v"><span id="badCnt">0</span></div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <div class="problem" id="problemBox">
            <button id="problemStartBtn" class="btn" type="button">시작</button>
          </div>
          <div id="lockNote" class="lock-note" style="display:none;">로그인 후 사용할 수 있습니다.</div>

          <div class="answerRow" id="answerRow">
            <input
              id="answerInput"
              type="text"
              inputmode="numeric"
              pattern="[0-9]*"
              autocomplete="off"
              placeholder="정답 입력"
              disabled
            />
            <button id="submitBtn" class="btn" style="border-radius:14px;" disabled>제출</button>
          </div>

          <div id="status" class="status"></div>

          <!-- On-screen keypad -->
          <div id="choiceBox" class="choices" style="display:none;"></div>

          <!-- On-screen keypad -->
          <div class="kbd" id="kbd" aria-label="숫자패드">
            <button class="kbtn" data-k="1">1</button>
            <button class="kbtn" data-k="2">2</button>
            <button class="kbtn" data-k="3">3</button>
            <button class="kbtn" data-k="4">4</button>
            <button class="kbtn" data-k="5">5</button>
            <button class="kbtn" data-k="6">6</button>
            <button class="kbtn" data-k="7">7</button>
            <button class="kbtn" data-k="8">8</button>
            <button class="kbtn" data-k="9">9</button>
            <button class="kbtn" data-k="0">0</button>
            <button class="kbtn danger" data-act="del">⌫</button>
          </div>

        </div>
      </div>

      <!-- RIGHT: INFO -->
      <div class="card">
        <div style="font-weight:800; margin-bottom:6px;">난이도 규칙</div>
        <div class="small" id="ruleText"></div>

        <div class="hr"></div>

        <div style="font-weight:800; margin-bottom:6px;">현재 세트 설정</div>
        <div class="small" id="settingText"></div>

        <div class="hr"></div>

        <div style="font-weight:800; margin-bottom:6px;">메모</div>
        <ul class="small" style="margin:0; padding-left:18px;">
          <li>문제를 푸신 뒤, 우측 상단 약점 확인으로 복습하세요.</li>
          <li>약점확인-인쇄버튼 : 약점을 프린트해서 보실 수 있습니다.</li>
          <li>곱셈/나눗셈은 2단계까지만 훈련하셔도 됩니다.</li>
        </ul>
      </div>

    </div>
    <div class="site-footer" id="siteVersion"></div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script>
    const APP_VERSION = "1.0.1";

    // ====== Difficulty ladders (as requested) ======
    const ladders = {
      add: [
        { name: "(두자리,한자리)", a:2, b:1, t:2.0 },
        { name: "(두자리,두자리)", a:2, b:2, t:3.0 },
        { name: "(세자리,두자리)", a:3, b:2, t:4.0 },
        { name: "(세자리,세자리)", a:3, b:3, t:5.0 },
      ],
      sub: [
        { name: "(두자리,한자리)", a:2, b:1, t:2.5 },
        { name: "(두자리,두자리)", a:2, b:2, t:3.0 },
        { name: "(세자리,두자리)", a:3, b:2, t:4.0 },
        { name: "(세자리,세자리)", a:3, b:3, t:4.5 },
      ],
      mul: [
        { name: "(한자리,한자리)", a:1, b:1, t:1.5 },
        { name: "(두자리,한자리)", a:2, b:1, t:3.0 },
        { name: "(두자리,두자리)", a:2, b:2, t:10.0 },
      ],
      div: [
        { name: "(두자리,한자리)", a:2, b:1, t:2.0 },
        { name: "(두자리,두자리)", a:2, b:2, t:2.5 },
        { name: "(세자리,한자리)", a:3, b:1, t:8.0 },
        { name: "(세자리,두자리)", a:3, b:2, t:8.0 },
      ],
      trig: [
        { name: "(1단계)", a:0, b:0, t:3.5 }
      ]
    };

    // ====== DOM ======
    const googleLoginBtn = document.getElementById("googleLoginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const authStatus = document.getElementById("authStatus");
    const siteVersion = document.getElementById("siteVersion");
    const lockNote = document.getElementById("lockNote");
    siteVersion.textContent = `ver ${APP_VERSION}`;

    const opSelect = document.getElementById("opSelect");
    const levelSelect = document.getElementById("levelSelect");
    const ruleText = document.getElementById("ruleText");
    const settingText = document.getElementById("settingText");

    const usePerQ = document.getElementById("usePerQ");
    const perQSec = document.getElementById("perQSec");
    const useSet = document.getElementById("useSet");
    const setSec = document.getElementById("setSec");

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");

    const setTimerBarWrap = document.getElementById("setTimerBarWrap");
    const setTimerBarFill = document.getElementById("setTimerBarFill");
    const qTimerBarWrap = document.getElementById("qTimerBarWrap");
    const qTimerBarFill = document.getElementById("qTimerBarFill");
    const okCntEl = document.getElementById("okCnt");
    const badCntEl = document.getElementById("badCnt");

    const problemBox = document.getElementById("problemBox");
    const answerRow = document.getElementById("answerRow");
    const answerInput = document.getElementById("answerInput");
    const submitBtn = document.getElementById("submitBtn");
    const statusEl = document.getElementById("status");
    const choiceBox = document.getElementById("choiceBox");
    const kbd = document.getElementById("kbd");

    // ====== State ======
    let running = false;
    let current = null; // {a,b,op,answer,shownText}
    let okCnt = 0, badCnt = 0;
    let isLocked = true;
    let qStartAt = null;
    let currentUserId = null;
    let currentUserEmail = null;

    let setTimer = null, qTimer = null;
    let setBarRaf = null, qBarRaf = null;
    let setEndAt = null, qEndAt = null;
    let setLimitMs = null, qLimitMs = null;

    // ====== Helpers ======
    function randint(min, max){
      // inclusive
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function pow10(n){ return Math.pow(10, n); }
    function randNDigits(d){
      // 1-digit: 1..9 (avoid zero)
      // >=2-digit: 10^(d-1) .. 10^d - 1
      if(d === 1) return randint(1, 9);
      return randint(pow10(d-1), pow10(d)-1);
    }
    const TRIG_CHOICES = {
      sincos: ["0", "1/2", "√2/2", "√3/2", "1"],
      tan: ["0", "1/3", "√3/3", "1", "√3"]
    };
    const TRIG_TABLE = {
      "deg:0":   { sin:"0",     cos:"1",     tan:"0" },
      "deg:30":  { sin:"1/2",   cos:"√3/2",  tan:"√3/3" },
      "deg:45":  { sin:"√2/2",  cos:"√2/2",  tan:"1" },
      "deg:60":  { sin:"√3/2",  cos:"1/2",   tan:"√3" },
      "deg:90":  { sin:"1",     cos:"0",     tan:null },
      "rad:π/6": { sin:"1/2",   cos:"√3/2",  tan:"√3/3" },
      "rad:π/4": { sin:"√2/2",  cos:"√2/2",  tan:"1" },
      "rad:π/3": { sin:"√3/2",  cos:"1/2",   tan:"√3" },
      "rad:π/2": { sin:"1",     cos:"0",     tan:null }
    };
    function escapeHTML(str){
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }
    function formatMathHTML(text){
      const escaped = escapeHTML(String(text));
      return escaped.replace(/(π|√\d+|\d+)\s*\/\s*(\d+)/g, (_m, a, b) => {
        return `<span class="frac"><span class="top">${a}</span><span class="bottom">${b}</span></span>`;
      });
    }
    function updateRuleUI(){
      const op = opSelect.value;
      const ladder = ladders[op];
      const idx = levelSelect.selectedIndex;
      const lvl = ladder[idx];
      const sym = op === "add" ? "+" : op === "sub" ? "−" : op === "mul" ? "×" : op === "div" ? "÷" : "";

      let extra = "";
      if(op === "div") extra = " (항상 정수로 나누어떨어짐)";
      if(op === "sub") extra = " (음수 방지: 큰 수 − 작은 수)";
      if(usePerQ.checked){
        perQSec.value = lvl.t.toFixed(1);
        syncWeakLimit(op, lvl.name, lvl.t);
      }
      ruleText.textContent =
        `${opLabel(op)} ${sym} 난이도: ${lvl.name}${extra}`;
      updateSettingUI();
    }
    function updateSettingUI(){
      const parts = [];
      parts.push(`연산: ${opLabel(opSelect.value)}`);
      parts.push(`난이도: ${levelSelect.value}`);
      parts.push(`문제당 제한시간: ${usePerQ.checked ? perQSec.value + "초" : "OFF"}`);
      parts.push(`세트 제한시간: ${useSet.checked ? setSec.value + "초" : "OFF"}`);
      settingText.textContent = parts.join(" / ");
    }
    function opLabel(op){
      return op === "add" ? "덧셈" : op === "sub" ? "뺄셈" : op === "mul" ? "곱셈" : op === "div" ? "나눗셈" : "삼각함수";
    }
    function setUIRunning(on){
      running = on;
      startBtn.disabled = on;
      stopBtn.disabled = !on;
      answerInput.disabled = !on;
      submitBtn.disabled = !on;
      opSelect.disabled = on;
      levelSelect.disabled = on;
      usePerQ.disabled = on;
      perQSec.disabled = on || !usePerQ.checked;
      useSet.disabled = on;
      setSec.disabled = on || !useSet.checked;
      statusEl.className = "status";
      statusEl.textContent = "";
      if(isLocked){
        startBtn.disabled = true;
        stopBtn.disabled = true;
        answerInput.disabled = true;
        submitBtn.disabled = true;
        opSelect.disabled = true;
        levelSelect.disabled = true;
      usePerQ.disabled = true;
      perQSec.disabled = true;
        useSet.disabled = true;
        setSec.disabled = true;
      }
      if(on){
        // focus input (mobile may show keyboard only on user gesture; still fine)
        setTimeout(() => answerInput.focus(), 50);
      }
    }

    function setGameLocked(locked){
      isLocked = locked;
      lockNote.style.display = locked ? "block" : "none";
      if(locked){
        if(running) endRun("로그인이 필요합니다.");
        problemBox.textContent = "로그인 후 시작하세요";
      } else {
        setIdleProblem();
      }
      setUIRunning(false);
    }

    function updateAuthUI(user){
      if(user){
        const label = user.displayName || user.email || "로그인됨";
        authStatus.textContent = `로그인됨: ${label}`;
        logoutBtn.disabled = false;
        googleLoginBtn.disabled = true;
        setGameLocked(false);
      } else {
        const privateHint = authPersistenceMode === "NONE"
          ? " (시크릿/추적방지 환경에서는 로그인 유지가 제한될 수 있습니다.)"
          : "";
        authStatus.textContent = `로그인하지 않으면 게임을 사용할 수 없습니다.${privateHint}`;
        logoutBtn.disabled = true;
        googleLoginBtn.disabled = false;
        setGameLocked(true);
      }
    }

    function setIdleProblem(){
      if(isLocked) return;
      problemBox.innerHTML = '<button id="problemStartBtn" class="btn" type="button">시작</button>';
      const btn = document.getElementById("problemStartBtn");
      btn.addEventListener("click", () => {
        if(isLocked || running) return;
        startBtn.click();
      });
      choiceBox.style.display = "none";
      answerRow.style.display = "flex";
      kbd.style.display = "grid";
      setQuestionBarRatio(0);
      // no help text
    }

    function setTimerBarRatio(wrapEl, fillEl, ratio, enabled){
      if(!wrapEl || !fillEl) return;
      if(!enabled){
        wrapEl.classList.add("off");
        fillEl.classList.remove("warn", "danger");
        fillEl.style.width = "0%";
        return;
      }
      const pct = Math.max(0, Math.min(1, ratio));
      wrapEl.classList.remove("off");
      fillEl.style.width = `${(pct * 100).toFixed(1)}%`;
      if(pct <= 0.25){
        fillEl.classList.add("danger");
        fillEl.classList.remove("warn");
      } else if(pct <= 0.5){
        fillEl.classList.add("warn");
        fillEl.classList.remove("danger");
      } else {
        fillEl.classList.remove("warn", "danger");
      }
    }
    function setSetBarRatio(ratio){
      setTimerBarRatio(setTimerBarWrap, setTimerBarFill, ratio, useSet.checked);
    }
    function setQuestionBarRatio(ratio){
      setTimerBarRatio(qTimerBarWrap, qTimerBarFill, ratio, usePerQ.checked);
    }

    function clearTimers(){
      if(setTimer){ clearInterval(setTimer); setTimer = null; }
      if(qTimer){ clearInterval(qTimer); qTimer = null; }
      if(setBarRaf){ cancelAnimationFrame(setBarRaf); setBarRaf = null; }
      if(qBarRaf){ cancelAnimationFrame(qBarRaf); qBarRaf = null; }
      setEndAt = null;
      qEndAt = null;
      setLimitMs = null;
      qLimitMs = null;
      setSetBarRatio(0);
      setQuestionBarRatio(0);
    }

    function startSetTimers(){
      clearTimers();
      const now = Date.now();

      if(useSet.checked){
        const s = clampInt(setSec.value, 10, 600);
        setSec.value = s;
        setLimitMs = s * 1000;
        setEndAt = now + setLimitMs;
        setSetBarRatio(1);
        const tickSetBar = () => {
          if(!setEndAt || !setLimitMs) return;
          const leftMs = setEndAt - Date.now();
          setSetBarRatio(leftMs / setLimitMs);
          if(leftMs > 0){
            setBarRaf = requestAnimationFrame(tickSetBar);
          } else {
            setBarRaf = null;
          }
        };
        setBarRaf = requestAnimationFrame(tickSetBar);
        setTimer = setInterval(() => {
          const leftMs = setEndAt - Date.now();
          if(leftMs <= 0){
            endRun("세트 시간이 종료되었습니다.");
          }
        }, 120);
      } else {
        setSetBarRatio(0);
      }
    }

    function startQuestionTimer(){
      if(qTimer){ clearInterval(qTimer); qTimer = null; }
      if(qBarRaf){ cancelAnimationFrame(qBarRaf); qBarRaf = null; }
      qEndAt = null;

      if(usePerQ.checked){
        const s = clampFloat(perQSec.value, 0.5, 30);
        perQSec.value = s.toFixed(1);
        qLimitMs = s * 1000;
        qEndAt = Date.now() + qLimitMs;
        setQuestionBarRatio(1);
        const tickBar = () => {
          if(!qEndAt || !qLimitMs) return;
          const leftMs = qEndAt - Date.now();
          const ratio = leftMs / qLimitMs;
          setQuestionBarRatio(ratio);
          if(leftMs > 0){
            qBarRaf = requestAnimationFrame(tickBar);
          } else {
            qBarRaf = null;
          }
        };
        qBarRaf = requestAnimationFrame(tickBar);
        qTimer = setInterval(() => {
          const leftMs = qEndAt - Date.now();
          if(leftMs <= 0){
            // time out counts as bad, then next
            recordAttempt("timeout", null);
            registerBad(`시간초과! 정답은 ${current.answer}`);
            nextProblem();
          }
        }, 60);
      } else {
        setQuestionBarRatio(0);
      }
    }

    function clampInt(v, min, max){
      const n = parseInt(v, 10);
      if(Number.isNaN(n)) return min;
      return Math.min(max, Math.max(min, n));
    }
    function clampFloat(v, min, max){
      const n = parseFloat(v);
      if(Number.isNaN(n)) return min;
      return Math.min(max, Math.max(min, n));
    }

    function getCurrentLimit(){
      const op = opSelect.value;
      const ladder = ladders[op];
      const lvl = ladder[levelSelect.selectedIndex];
      return lvl.t;
    }

    function loadStats(uid){
      try{
        const raw = localStorage.getItem(`ms_stats_${uid}`);
        return raw ? JSON.parse(raw) : {};
      } catch(e){
        return {};
      }
    }
    function saveStats(uid, data){
      localStorage.setItem(`ms_stats_${uid}`, JSON.stringify(data));
    }
    function saveAttempt(entry){
      if(!currentUserId) return;
      db.collection("attempts").add({
        uid: currentUserId,
        email: currentUserEmail || null,
        op: entry.op,
        level: entry.level,
        problem: entry.problem,
        answer: entry.answer,
        userAnswer: entry.userAnswer === undefined ? null : entry.userAnswer,
        result: entry.result,
        time: entry.time,
        limit: entry.limit,
        clientTs: entry.ts,
        serverTs: firebase.firestore.FieldValue.serverTimestamp()
      }).catch(() => {});
    }
    function loadWeak(uid){
      try{
        const raw = localStorage.getItem(`ms_weak_${uid}`);
        return raw ? JSON.parse(raw) : { items: {} };
      } catch(e){
        return { items: {} };
      }
    }
    function saveWeak(uid, data){
      localStorage.setItem(`ms_weak_${uid}`, JSON.stringify(data));
    }
    function syncWeakLimit(op, level, limit){
      if(!currentUserId) return;
      const data = loadWeak(currentUserId);
      const items = data.items || {};
      let changed = false;
      Object.values(items).forEach(item => {
        if(item.op === op && item.level === level){
          item.limit = limit;
          changed = true;
        }
      });
      if(changed) saveWeak(currentUserId, data);
    }
    function makeWeakId(entry){
      return `${entry.op}|${entry.level}|${entry.problem}|${entry.answer}`;
    }
    function upsertWeakness(entry, reason){
      const data = loadWeak(currentUserId);
      const id = makeWeakId(entry);
      const now = Date.now();
      const item = data.items[id] || {
        id,
        op: entry.op,
        level: entry.level,
        problem: entry.problem,
        answer: entry.answer,
        limit: entry.limit,
        choices: entry.choices || null,
        reasons: { wrong: false, slow: false },
        stage: 0,
        nextAt: now,
        lastResult: entry.result,
        lastTime: entry.time,
        lastTs: entry.ts
      };
      item.limit = entry.limit;
      item.choices = entry.choices || null;
      item.reasons.wrong = item.reasons.wrong || !!reason.wrong;
      item.reasons.slow = item.reasons.slow || !!reason.slow;
      item.stage = 0;
      item.nextAt = now;
      item.lastResult = entry.result;
      item.lastTime = entry.time;
      item.lastTs = entry.ts;
      data.items[id] = item;
      saveWeak(currentUserId, data);
    }

    function recordAttempt(result, userAnswer){
      if(!currentUserId || !current) return;
      const timeSec = qStartAt ? (Date.now() - qStartAt) / 1000 : 0;
      const limitSec = getCurrentLimit();
      const entry = {
        op: opSelect.value,
        level: levelSelect.value,
        problem: current.shownText,
        answer: current.answer,
        userAnswer: userAnswer,
        choices: current.isChoice ? (current.choices || []) : null,
        time: Number(timeSec.toFixed(1)),
        limit: limitSec,
        result: result,
        ts: Date.now()
      };

      const data = loadStats(currentUserId);
      if(!data[entry.op]) data[entry.op] = { wrong: [], slow: [] };
      if(result !== "correct"){
        data[entry.op].wrong.push(entry);
      }
      if(entry.time >= limitSec){
        data[entry.op].slow.push(entry);
      }
      saveStats(currentUserId, data);

      const reason = {
        wrong: result !== "correct",
        slow: entry.time >= limitSec
      };
      if(reason.wrong || reason.slow){
        upsertWeakness(entry, reason);
      }
      saveAttempt(entry);
    }

    function genProblem(){
      const op = opSelect.value;
      const ladder = ladders[op];
      const lvl = ladder[levelSelect.selectedIndex];

      let a = 0;
      let b = 0;
      if(op !== "trig"){
        a = randNDigits(lvl.a);
        b = randNDigits(lvl.b);
      }

      // Avoid super-trivial for multi-digit: prevent b=0 in division and multiplication?
      // We'll handle per-op.
      let answer, shown, choices, isChoice;

      if(op === "add"){
        answer = a + b;
        shown = `${a} + ${b}`;
      } else if(op === "sub"){
        // prevent negative: ensure a >= b
        if(a < b){ const t=a; a=b; b=t; }
        answer = a - b;
        shown = `${a} − ${b}`;
      } else if(op === "mul"){
        // optionally avoid 0 too often: if both digits are 1 and 0 appears too much, fine for now
        answer = a * b;
        shown = `${a} × ${b}`;
      } else if(op === "div"){
        // division: must divide evenly. We will create (dividend ÷ divisor) with exact quotient.
        // Given desired digit sizes: a digits = dividend, b digits = divisor
        // Approach: sample divisor (b digits, not 0), sample quotient (>=1),
        // compute dividend = divisor * quotient and ensure digit length matches a.
        const divisorDigits = lvl.b;
        const dividendDigits = lvl.a;

        let divisor, quotient, dividend;
        let tries = 0;
        while(true){
          tries++;
          if(tries > 2000){
            // fallback (shouldn't happen)
            divisor = Math.max(1, randNDigits(divisorDigits));
            quotient = randint(1, 9);
            dividend = divisor * quotient;
            break;
          }

          divisor = randNDigits(divisorDigits);
          if(divisor === 0) continue;

          // choose quotient range to get dividend digits roughly right
          // dividend ≈ divisor * quotient should have dividendDigits digits
          const minDividend = dividendDigits === 1 ? 0 : pow10(dividendDigits - 1);
          const maxDividend = pow10(dividendDigits) - 1;

          // quotient bounds: ceil(minDividend/divisor) .. floor(maxDividend/divisor)
          const qMin = Math.ceil(minDividend / divisor);
          const qMax = Math.floor(maxDividend / divisor);

          const qLo = Math.max(1, qMin);
          const qHi = Math.max(1, qMax);
          if(qLo > qHi) continue;

          quotient = randint(qLo, qHi);
          dividend = divisor * quotient;

          // ensure exact digit length match (especially for 2-digit min could be 10)
          if(dividend < minDividend || dividend > maxDividend) continue;

          // pass
          break;
        }
        a = dividend;
        b = divisor;
        answer = quotient;
        shown = `${a} ÷ ${b}`;
      } else if(op === "trig"){
        const funcs = ["sin", "cos", "tan"];
        const func = funcs[randint(0, funcs.length - 1)];
        const useRad = Math.random() < 0.5;
        const degAngles = [0, 30, 45, 60, 90];
        const radAngles = ["π/6", "π/4", "π/3", "π/2"];
        let angleText = "";
        let key = "";
        if(useRad){
          let candidates = radAngles.slice();
          if(func === "tan"){ candidates = candidates.filter(a => a !== "π/2"); }
          const angle = candidates[randint(0, candidates.length - 1)];
          angleText = angle;
          key = `rad:${angle}`;
        } else {
          let candidates = degAngles.slice();
          if(func === "tan"){ candidates = candidates.filter(a => a !== 90); }
          const angle = candidates[randint(0, candidates.length - 1)];
          angleText = `${angle}°`;
          key = `deg:${angle}`;
        }
        answer = TRIG_TABLE[key][func];
        shown = `${func} ${angleText}`;
        choices = func === "tan" ? TRIG_CHOICES.tan : TRIG_CHOICES.sincos;
        isChoice = true;
      }

      return { a, b, op, answer, shownText: shown, choices, isChoice };
    }

    function renderProblem(){
      problemBox.innerHTML = formatMathHTML(current.shownText);
      answerInput.value = "";
      statusEl.className = "status";
      statusEl.textContent = "";
      if(current.isChoice){
        choiceBox.style.display = "grid";
        renderChoices(current.choices || []);
        answerInput.disabled = true;
        submitBtn.disabled = true;
        answerRow.style.display = "none";
        kbd.style.display = "none";
        // no help text
      } else {
        choiceBox.style.display = "none";
        answerInput.disabled = false;
        submitBtn.disabled = false;
        answerRow.style.display = "flex";
        kbd.style.display = "grid";
        // no help text
      }
      qStartAt = Date.now();
      startQuestionTimer();
    }

    function registerOk(msg){
      okCnt++;
      okCntEl.textContent = okCnt;
      statusEl.className = "status ok";
      statusEl.textContent = msg;
    }
    function registerBad(msg){
      badCnt++;
      badCntEl.textContent = badCnt;
      statusEl.className = "status bad";
      statusEl.textContent = msg;
    }

    function nextProblem(){
      if(!running) return;
      current = genProblem();
      renderProblem();
      answerInput.focus();
    }

    function endRun(msg){
      setUIRunning(false);
      running = false;
      clearTimers();
      setIdleProblem();
      statusEl.className = "status";
      statusEl.textContent = msg || "";
      answerInput.value = "";
    }

    function renderChoices(choices){
      choiceBox.innerHTML = "";
      choices.forEach(val => {
        const btn = document.createElement("button");
        btn.className = "choice-btn";
        btn.type = "button";
        btn.innerHTML = formatMathHTML(val);
        btn.addEventListener("click", () => submitChoice(val));
        choiceBox.appendChild(btn);
      });
    }

    function submitChoice(val){
      if(!running || !current || !current.isChoice) return;
      if(val === current.answer){
        recordAttempt("correct", val);
        registerOk("정답!");
      } else {
        recordAttempt("wrong", val);
        registerBad(`오답! 정답은 ${current.answer}`);
      }
      nextProblem();
    }

    function submitAnswer(){
      if(!running || !current) return;
      if(current.isChoice) return;

      const raw = answerInput.value.trim();
      if(raw === "") return;

      const userAns = parseInt(raw, 10);
      if(Number.isNaN(userAns)) return;

      if(userAns === current.answer){
        recordAttempt("correct", userAns);
        registerOk("정답!");
      } else {
        recordAttempt("wrong", userAns);
        registerBad(`오답! 정답은 ${current.answer}`);
      }
      nextProblem();
    }

    function autoSubmitIfCorrect(){
      if(!running || !current || current.isChoice) return;
      const raw = answerInput.value.trim();
      if(raw === "") return;
      const userAns = parseInt(raw, 10);
      if(Number.isNaN(userAns)) return;
      if(userAns === current.answer){
        submitAnswer();
      }
    }

    // ====== UI init ======
    function populateLevelOptions(){
      levelSelect.innerHTML = "";
      const op = opSelect.value;
      const ladder = ladders[op];
      ladder.forEach((lvl, i) => {
        const opt = document.createElement("option");
        opt.value = lvl.name;
        opt.textContent = `${i+1}. ${lvl.name}`;
        levelSelect.appendChild(opt);
      });
      levelSelect.selectedIndex = 0;
      updateRuleUI();
    }

    // ====== Firebase Auth (Google) ======
    const firebaseConfig = {
      apiKey: "AIzaSyA_UHGO2HW07NLlNlKyejzHOpCZPwm30TA",
      authDomain: "math-sprint-9c129.firebaseapp.com",
      projectId: "math-sprint-9c129",
      storageBucket: "math-sprint-9c129.firebasestorage.app",
      messagingSenderId: "358959824417",
      appId: "1:358959824417:web:21c328839c758c77b16d60",
      measurementId: "G-WTT3YC0BTW"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const provider = new firebase.auth.GoogleAuthProvider();
    provider.setCustomParameters({ prompt: "select_account" });
    let authPersistenceMode = "LOCAL";

    function isMobile(){
      return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
    }

    function isInAppBrowser(){
      const ua = navigator.userAgent || "";
      return /KAKAOTALK|FBAN|FBAV|Instagram|Line|NAVER|wv|WebView/i.test(ua);
    }

    function shouldFallbackToRedirect(err){
      const code = err && err.code ? err.code : "";
      return code === "auth/popup-blocked" || code === "auth/operation-not-supported-in-this-environment";
    }

    function loginErrorText(err){
      const code = err && err.code ? err.code : "unknown";
      if(code === "auth/missing-initial-state"){
        return "인앱브라우저에서는 리디렉트 로그인이 실패할 수 있습니다. 우측 상단 메뉴에서 외부 브라우저(Chrome/Safari)로 열어 다시 로그인해주세요.";
      }
      if(code === "auth/web-storage-unsupported"){
        return "브라우저가 로그인 저장소를 차단했습니다. 시크릿 모드를 끄고 다시 시도해주세요.";
      }
      if(code === "auth/popup-closed-by-user"){
        return "로그인 창이 닫혀 취소되었습니다.";
      }
      if((code === "auth/popup-blocked" || code === "auth/operation-not-supported-in-this-environment") && isInAppBrowser()){
        return "카카오톡 인앱브라우저에서는 Google 로그인이 제한될 수 있습니다. 외부 브라우저로 열어 로그인해주세요.";
      }
      return `로그인 오류: ${code}`;
    }

    // ====== Events ======
    async function initAuthPersistence(){
      const options = [
        { name: "LOCAL", value: firebase.auth.Auth.Persistence.LOCAL },
        { name: "SESSION", value: firebase.auth.Auth.Persistence.SESSION },
        { name: "NONE", value: firebase.auth.Auth.Persistence.NONE }
      ];
      for(const opt of options){
        try{
          await auth.setPersistence(opt.value);
          authPersistenceMode = opt.name;
          return;
        } catch(e){}
      }
      authPersistenceMode = "NONE";
    }

    const authReady = (async () => {
      await initAuthPersistence();
      try{
        await auth.getRedirectResult();
      } catch(e){}
    })();

    googleLoginBtn.addEventListener("click", async () => {
      let redirectStarted = false;
      try{
        googleLoginBtn.disabled = true;
        // Ensure persistence/redirect bootstrap is finished before first sign-in attempt.
        await authReady;
        authStatus.textContent = "로그인 창을 여는 중...";
        // Popup first (works better than redirect in some private-mode browsers)
        try{
          await auth.signInWithPopup(provider);
          return;
        } catch(popupErr){
          if(!shouldFallbackToRedirect(popupErr) || authPersistenceMode === "NONE" || isInAppBrowser()){
            throw popupErr;
          }
          authStatus.textContent = isMobile()
            ? "팝업이 제한되어 리디렉트 로그인으로 전환합니다."
            : "팝업이 차단되어 리디렉트 로그인으로 전환합니다.";
          redirectStarted = true;
          await auth.signInWithRedirect(provider);
          return;
        }
      } catch(e){
        authStatus.textContent = loginErrorText(e);
      } finally {
        if(!redirectStarted){
          googleLoginBtn.disabled = false;
        }
      }
    });

    logoutBtn.addEventListener("click", async () => {
      await auth.signOut();
    });

    authReady.finally(() => {
      auth.onAuthStateChanged((user) => {
        currentUserId = user ? user.uid : null;
        currentUserEmail = user ? user.email : null;
        updateAuthUI(user);
      });
    });

    opSelect.addEventListener("change", () => {
      populateLevelOptions();
    });
    levelSelect.addEventListener("change", updateRuleUI);

    usePerQ.addEventListener("change", () => {
      perQSec.disabled = running || !usePerQ.checked;
      if(usePerQ.checked){
        updateRuleUI();
        setQuestionBarRatio(1);
      } else {
        setQuestionBarRatio(0);
      }
      updateSettingUI();
    });
    useSet.addEventListener("change", () => {
      setSec.disabled = running || !useSet.checked;
      if(useSet.checked){
        setSetBarRatio(1);
      } else {
        setSetBarRatio(0);
      }
      updateSettingUI();
    });
    perQSec.addEventListener("input", () => {
      if(usePerQ.checked){
        const v = clampFloat(perQSec.value, 0.5, 30);
        perQSec.value = v.toFixed(1);
        syncWeakLimit(opSelect.value, levelSelect.value, v);
      }
      updateSettingUI();
    });
    setSec.addEventListener("input", updateSettingUI);

    startBtn.addEventListener("click", () => {
      if(isLocked){
        statusEl.className = "status bad";
        statusEl.textContent = "로그인 후 이용할 수 있습니다.";
        return;
      }
      okCnt = 0; badCnt = 0;
      okCntEl.textContent = "0";
      badCntEl.textContent = "0";

      setUIRunning(true);
      running = true;
      startSetTimers();
      nextProblem();
    });

    stopBtn.addEventListener("click", () => {
      endRun("중지되었습니다.");
    });

    submitBtn.addEventListener("click", submitAnswer);
    answerInput.addEventListener("input", autoSubmitIfCorrect);

    // keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if(!running) return;
      if(e.key === "Enter"){
        e.preventDefault();
        submitAnswer();
      }
      // allow minus? not needed (we generate non-negative results)
    });

    // On-screen keypad
    document.querySelectorAll(".kbtn").forEach(btn => {
      btn.addEventListener("click", () => {
        if(answerInput.disabled) return;
        const k = btn.getAttribute("data-k");
        const act = btn.getAttribute("data-act");
        if(k !== null){
          answerInput.value += k;
          answerInput.focus();
        } else if(act === "del"){
          answerInput.value = answerInput.value.slice(0, -1);
          answerInput.focus();
        }
      });
    });

    // init
    populateLevelOptions();
    updateSettingUI();
    setIdleProblem();
    usePerQ.checked = true;
    usePerQ.disabled = false;
    perQSec.disabled = !usePerQ.checked;
    setSetBarRatio(1);
    setQuestionBarRatio(1);
  </script>
</body>
</html>
