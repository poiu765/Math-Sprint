<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>수능 기초 체력 훈련</title>
  <style>
    :root{
      --bg:#ffffff;
      --fg:#111111;
      --muted:#6b7280;
      --line:#e5e7eb;
      --accent:#111111;
      --danger:#b91c1c;
      --ok:#047857;
      --card:#fafafa;
      --btn:#111111;
      --btnfg:#ffffff;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      line-height:1.35;
    }
    .wrap{ max-width:980px; margin:0 auto; padding:20px; }
    h1{ margin:0 0 12px; font-size:20px; }
    .grid{
      display:grid; gap:12px;
      grid-template-columns: 1fr;
    }
    @media (min-width: 900px){
      .grid{ grid-template-columns: 1.1fr 0.9fr; }
    }
    .card{
      border:1px solid var(--line);
      background:var(--card);
      border-radius:12px;
      padding:14px;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label{ font-size:13px; color:var(--muted); }
    select, input[type="number"], input[type="text"]{
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:10px;
      background:#fff;
      font-size:16px;
      outline:none;
    }
    select:focus, input:focus{ border-color:#c7c7c7; }
    .btn{
      padding:10px 14px;
      border:1px solid var(--btn);
      background:var(--btn);
      color:var(--btnfg);
      border-radius:10px;
      font-size:15px;
      cursor:pointer;
    }
    .btn.secondary{
      background:#fff; color:var(--fg); border-color:var(--line);
    }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .meta{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
      margin-top:10px;
    }
    .pill{
      border:1px solid var(--line);
      border-radius:10px;
      padding:10px 12px;
      background:#fff;
    }
    .pill .k{ font-size:12px; color:var(--muted); }
    .pill .v{ font-size:18px; font-weight:700; margin-top:2px; }
    .problem{
      display:flex; align-items:center; justify-content:center;
      background:#fff;
      border:1px solid var(--line);
      border-radius:14px;
      padding:18px;
      min-height:84px;
      font-size:34px;
      font-weight:800;
      letter-spacing:.5px;
      user-select:none;
    }
    .problem .btn{
      font-size:20px;
      padding:12px 20px;
      border-radius:12px;
    }
    .answerRow{
      display:flex; gap:10px; margin-top:10px; align-items:stretch;
    }
    .answerRow input{
      flex:1;
      font-size:22px;
      padding:14px 14px;
      border-radius:14px;
    }
    .status{
      margin-top:10px; min-height:22px;
      font-size:14px; color:var(--muted);
    }
    .status.ok{ color:var(--ok); font-weight:700; }
    .status.bad{ color:var(--danger); font-weight:700; }
    .kbd{
      margin-top:12px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:10px;
    }
    .kbtn{
      padding:18px 0;
      border-radius:14px;
      border:1px solid var(--line);
      background:#fff;
      font-size:22px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
    }
    .kbtn:active{ transform: translateY(1px); }
    .kbtn.wide{ grid-column: span 2; }
    .kbtn.action{
      background:var(--btn); color:var(--btnfg); border-color:var(--btn);
    }
    .kbtn.danger{
      background:#fff; color:var(--danger); border-color:#f3c5c5;
    }
    .choices{
      margin-top:10px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:10px;
    }
    .choice-btn{
      padding:12px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#fff;
      font-size:16px;
      font-weight:700;
      cursor:pointer;
      user-select:none;
    }
    .choice-btn:active{ transform: translateY(1px); }
    .frac{
      display:inline-flex;
      flex-direction:column;
      align-items:center;
      line-height:1;
      vertical-align:middle;
      margin:0 2px;
    }
    .frac .top{
      border-bottom:1px solid currentColor;
      padding:0 2px 2px;
      font-size:0.95em;
    }
    .frac .bottom{
      padding:2px 2px 0;
      font-size:0.95em;
    }
    .help{ font-size:12px; color:var(--muted); margin-top:8px; }
    .hr{ height:1px; background:var(--line); margin:12px 0; }
    .small{ font-size:12px; color:var(--muted); }
    .toggle{
      display:flex; gap:8px; align-items:center;
      padding:8px 10px; border:1px solid var(--line);
      border-radius:10px; background:#fff;
    }
    input[type="checkbox"]{ width:18px; height:18px; }
    .auth-note{
      font-size:12px; color:var(--muted);
    }
    .lock-note{
      margin-top:8px; font-size:12px; color:var(--danger);
      font-weight:700;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <h1 style="margin:0;">수학 기초 훈련</h1>
      <a href="stats.html" class="btn secondary">약점 확인</a>
    </div>

    <div class="card" id="authCard">
      <div style="font-weight:800; margin-bottom:6px;">로그인</div>
      <div class="row" style="margin-top:10px;">
        <button id="googleLoginBtn" class="btn">Google로 로그인</button>
        <button id="logoutBtn" class="btn secondary" disabled>로그아웃</button>
        <div class="auth-note" id="authStatus">로그인하지 않으면 게임을 사용할 수 없습니다.</div>
      </div>
      <div class="auth-note">※ Google 계정으로 로그인합니다.</div>
      <div class="row" style="margin-top:10px;">
        <div style="min-width:140px;">
          <label>닉네임</label><br/>
          <input id="nicknameInput" type="text" placeholder="2~12자" />
        </div>
        <button id="nicknameSaveBtn" class="btn secondary" type="button" disabled>저장</button>
        <div class="auth-note" id="nicknameStatus"></div>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: GAME -->
      <div class="card" id="gameCard">
        <div class="row">
          <div style="flex:1; min-width:220px;">
            <label>기초</label><br/>
            <select id="opSelect">
              <option value="add">덧셈</option>
              <option value="sub">뺄셈</option>
              <option value="mul">곱셈</option>
              <option value="div">나눗셈</option>
              <option value="trig">삼각함수</option>
            </select>
          </div>

          <div style="flex:1; min-width:220px;">
            <label>난이도 단계</label><br/>
            <select id="levelSelect"></select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div class="toggle">
            <input id="usePerQ" type="checkbox" checked />
            <label for="usePerQ" style="margin:0;color:var(--fg);">문제당 제한시간(초)</label>
            <input id="perQSec" type="number" min="0.5" max="30" step="0.1" value="5" style="width:90px;" />
          </div>

          <div class="toggle">
            <input id="useSet" type="checkbox" checked />
            <label for="useSet" style="margin:0;color:var(--fg);">세트 제한시간(초)</label>
            <input id="setSec" type="number" min="10" max="600" value="30" style="width:110px;" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="startBtn" class="btn">시작</button>
          <button id="stopBtn" class="btn secondary" disabled>중지</button>
          <span class="small">PC: Enter 제출 / Backspace 삭제</span>
        </div>

        <div class="meta">
          <div class="pill">
            <div class="k">세트 남은 시간</div>
            <div class="v" id="setLeft">—</div>
          </div>
          <div class="pill">
            <div class="k">문제 남은 시간</div>
            <div class="v" id="qLeft">—</div>
          </div>
          <div class="pill">
            <div class="k">정답</div>
            <div class="v"><span id="okCnt">0</span></div>
          </div>
          <div class="pill">
            <div class="k">오답/시간초과</div>
            <div class="v"><span id="badCnt">0</span></div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <div class="problem" id="problemBox">
            <button id="problemStartBtn" class="btn" type="button">시작</button>
          </div>
          <div id="lockNote" class="lock-note" style="display:none;">로그인 후 사용할 수 있습니다.</div>

          <div class="answerRow" id="answerRow">
            <input
              id="answerInput"
              type="text"
              inputmode="numeric"
              pattern="[0-9]*"
              autocomplete="off"
              placeholder="정답 입력"
              disabled
            />
            <button id="submitBtn" class="btn" style="border-radius:14px;" disabled>제출</button>
          </div>

          <div id="status" class="status"></div>

          <!-- On-screen keypad -->
          <div id="choiceBox" class="choices" style="display:none;"></div>

          <!-- On-screen keypad -->
          <div class="kbd" id="kbd" aria-label="숫자패드">
            <button class="kbtn" data-k="1">1</button>
            <button class="kbtn" data-k="2">2</button>
            <button class="kbtn" data-k="3">3</button>
            <button class="kbtn" data-k="4">4</button>
            <button class="kbtn" data-k="5">5</button>
            <button class="kbtn" data-k="6">6</button>
            <button class="kbtn" data-k="7">7</button>
            <button class="kbtn" data-k="8">8</button>
            <button class="kbtn" data-k="9">9</button>
            <button class="kbtn danger" data-act="del">⌫</button>
            <button class="kbtn" data-k="0">0</button>
            <button class="kbtn action" data-act="enter">⏎</button>
          </div>

        </div>
      </div>

      <!-- RIGHT: INFO -->
      <div class="card">
        <div style="font-weight:800; margin-bottom:6px;">난이도 규칙</div>
        <div class="small" id="ruleText"></div>

        <div class="hr"></div>

        <div style="font-weight:800; margin-bottom:6px;">현재 세트 설정</div>
        <div class="small" id="settingText"></div>

        <div class="hr"></div>

        <div style="font-weight:800; margin-bottom:6px;">메모</div>
        <ul class="small" style="margin:0; padding-left:18px;">
          <li>나눗셈은 항상 정수로 나누어떨어지는 문제만 생성합니다.</li>
          <li>뺄셈은 기본적으로 음수가 나오지 않도록 생성합니다.</li>
        </ul>
      </div>

    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script>
    // ====== Difficulty ladders (as requested) ======
    const ladders = {
      add: [
        { name: "(두자리,한자리)", a:2, b:1, t:2.0 },
        { name: "(두자리,두자리)", a:2, b:2, t:2.5 },
        { name: "(세자리,두자리)", a:3, b:2, t:3.5 },
        { name: "(세자리,세자리)", a:3, b:3, t:4.0 },
      ],
      sub: [
        { name: "(두자리,한자리)", a:2, b:1, t:2.5 },
        { name: "(두자리,두자리)", a:2, b:2, t:3.0 },
        { name: "(세자리,두자리)", a:3, b:2, t:4.0 },
        { name: "(세자리,세자리)", a:3, b:3, t:4.5 },
      ],
      mul: [
        { name: "(한자리,한자리)", a:1, b:1, t:1.5 },
        { name: "(두자리,한자리)", a:2, b:1, t:2.5 },
        { name: "(두자리,두자리)", a:2, b:2, t:4.0 },
      ],
      div: [
        { name: "(두자리,한자리)", a:2, b:1, t:1.5 },
        { name: "(두자리,두자리)", a:2, b:2, t:2.5 },
        { name: "(세자리,한자리)", a:3, b:1, t:3.0 },
        { name: "(세자리,두자리)", a:3, b:2, t:4.0 },
      ],
      trig: [
        { name: "(1단계)", a:0, b:0, t:2.5 }
      ]
    };

    // ====== DOM ======
    const googleLoginBtn = document.getElementById("googleLoginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const authStatus = document.getElementById("authStatus");
    const lockNote = document.getElementById("lockNote");
    const nicknameInput = document.getElementById("nicknameInput");
    const nicknameSaveBtn = document.getElementById("nicknameSaveBtn");
    const nicknameStatus = document.getElementById("nicknameStatus");

    const opSelect = document.getElementById("opSelect");
    const levelSelect = document.getElementById("levelSelect");
    const ruleText = document.getElementById("ruleText");
    const settingText = document.getElementById("settingText");

    const usePerQ = document.getElementById("usePerQ");
    const perQSec = document.getElementById("perQSec");
    const useSet = document.getElementById("useSet");
    const setSec = document.getElementById("setSec");

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");

    const setLeftEl = document.getElementById("setLeft");
    const qLeftEl = document.getElementById("qLeft");
    const okCntEl = document.getElementById("okCnt");
    const badCntEl = document.getElementById("badCnt");

    const problemBox = document.getElementById("problemBox");
    const answerRow = document.getElementById("answerRow");
    const answerInput = document.getElementById("answerInput");
    const submitBtn = document.getElementById("submitBtn");
    const statusEl = document.getElementById("status");
    const choiceBox = document.getElementById("choiceBox");
    const kbd = document.getElementById("kbd");

    // ====== State ======
    let running = false;
    let current = null; // {a,b,op,answer,shownText}
    let okCnt = 0, badCnt = 0;
    let isLocked = true;
    let qStartAt = null;
    let currentUserId = null;
    let currentUserEmail = null;
    let currentNickname = null;

    let setTimer = null, qTimer = null;
    let setEndAt = null, qEndAt = null;

    // ====== Helpers ======
    function randint(min, max){
      // inclusive
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function pow10(n){ return Math.pow(10, n); }
    function randNDigits(d){
      // 1-digit: 1..9 (avoid zero)
      // >=2-digit: 10^(d-1) .. 10^d - 1
      if(d === 1) return randint(1, 9);
      return randint(pow10(d-1), pow10(d)-1);
    }
    const TRIG_CHOICES = {
      sincos: ["0", "1/2", "√2/2", "√3/2", "1"],
      tan: ["0", "1/3", "√3/3", "1", "√3"]
    };
    const TRIG_TABLE = {
      "deg:0":   { sin:"0",     cos:"1",     tan:"0" },
      "deg:30":  { sin:"1/2",   cos:"√3/2",  tan:"√3/3" },
      "deg:45":  { sin:"√2/2",  cos:"√2/2",  tan:"1" },
      "deg:60":  { sin:"√3/2",  cos:"1/2",   tan:"√3" },
      "deg:90":  { sin:"1",     cos:"0",     tan:null },
      "rad:π/6": { sin:"1/2",   cos:"√3/2",  tan:"√3/3" },
      "rad:π/4": { sin:"√2/2",  cos:"√2/2",  tan:"1" },
      "rad:π/3": { sin:"√3/2",  cos:"1/2",   tan:"√3" },
      "rad:π/2": { sin:"1",     cos:"0",     tan:null }
    };
    function escapeHTML(str){
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }
    function formatMathHTML(text){
      const escaped = escapeHTML(String(text));
      return escaped.replace(/(π|√\d+|\d+)\s*\/\s*(\d+)/g, (_m, a, b) => {
        return `<span class="frac"><span class="top">${a}</span><span class="bottom">${b}</span></span>`;
      });
    }
    function updateRuleUI(){
      const op = opSelect.value;
      const ladder = ladders[op];
      const idx = levelSelect.selectedIndex;
      const lvl = ladder[idx];
      const sym = op === "add" ? "+" : op === "sub" ? "−" : op === "mul" ? "×" : op === "div" ? "÷" : "";

      let extra = "";
      if(op === "div") extra = " (항상 정수로 나누어떨어짐)";
      if(op === "sub") extra = " (음수 방지: 큰 수 − 작은 수)";
      if(usePerQ.checked){
        perQSec.value = lvl.t.toFixed(1);
        syncWeakLimit(op, lvl.name, lvl.t);
      }
      ruleText.textContent =
        `${opLabel(op)} ${sym} 난이도: ${lvl.name}${extra}`;
      updateSettingUI();
    }
    function updateSettingUI(){
      const parts = [];
      parts.push(`연산: ${opLabel(opSelect.value)}`);
      parts.push(`난이도: ${levelSelect.value}`);
      parts.push(`문제당 제한시간: ${usePerQ.checked ? perQSec.value + "초" : "OFF"}`);
      parts.push(`세트 제한시간: ${useSet.checked ? setSec.value + "초" : "OFF"}`);
      settingText.textContent = parts.join(" / ");
    }
    function opLabel(op){
      return op === "add" ? "덧셈" : op === "sub" ? "뺄셈" : op === "mul" ? "곱셈" : op === "div" ? "나눗셈" : "삼각함수";
    }
    function setUIRunning(on){
      running = on;
      startBtn.disabled = on;
      stopBtn.disabled = !on;
      answerInput.disabled = !on;
      submitBtn.disabled = !on;
      opSelect.disabled = on;
      levelSelect.disabled = on;
      usePerQ.disabled = on;
      perQSec.disabled = on || !usePerQ.checked;
      useSet.disabled = on;
      setSec.disabled = on || !useSet.checked;
      statusEl.className = "status";
      statusEl.textContent = "";
      if(isLocked){
        startBtn.disabled = true;
        stopBtn.disabled = true;
        answerInput.disabled = true;
        submitBtn.disabled = true;
        opSelect.disabled = true;
        levelSelect.disabled = true;
      usePerQ.disabled = true;
      perQSec.disabled = true;
        useSet.disabled = true;
        setSec.disabled = true;
      }
      if(on){
        // focus input (mobile may show keyboard only on user gesture; still fine)
        setTimeout(() => answerInput.focus(), 50);
      }
    }

    function setGameLocked(locked){
      isLocked = locked;
      lockNote.style.display = locked ? "block" : "none";
      if(locked){
        if(running) endRun("로그인이 필요합니다.");
        problemBox.textContent = "로그인 후 시작하세요";
      } else {
        setIdleProblem();
      }
      setUIRunning(false);
    }

    function updateAuthUI(user){
      if(user){
        const label = user.displayName || user.email || "로그인됨";
        authStatus.textContent = `로그인됨: ${label}`;
        logoutBtn.disabled = false;
        googleLoginBtn.disabled = true;
        setGameLocked(false);
      } else {
        authStatus.textContent = "로그인하지 않으면 게임을 사용할 수 없습니다.";
        logoutBtn.disabled = true;
        googleLoginBtn.disabled = false;
        setGameLocked(true);
      }
    }

    function setIdleProblem(){
      if(isLocked) return;
      problemBox.innerHTML = '<button id="problemStartBtn" class="btn" type="button">시작</button>';
      const btn = document.getElementById("problemStartBtn");
      btn.addEventListener("click", () => {
        if(isLocked || running) return;
        startBtn.click();
      });
      choiceBox.style.display = "none";
      answerRow.style.display = "flex";
      kbd.style.display = "grid";
      // no help text
    }

    function clearTimers(){
      if(setTimer){ clearInterval(setTimer); setTimer = null; }
      if(qTimer){ clearInterval(qTimer); qTimer = null; }
      setEndAt = null;
      qEndAt = null;
      setLeftEl.textContent = "—";
      qLeftEl.textContent = "—";
    }

    function startSetTimers(){
      clearTimers();
      const now = Date.now();

      if(useSet.checked){
        const s = clampInt(setSec.value, 10, 600);
        setSec.value = s;
        setEndAt = now + s * 1000;
        setTimer = setInterval(() => {
          const leftMs = setEndAt - Date.now();
          const left = Math.max(0, Math.ceil(leftMs / 1000));
          setLeftEl.textContent = left + "s";
          if(leftMs <= 0){
            endRun("세트 시간이 종료되었습니다.");
          }
        }, 150);
      } else {
        setLeftEl.textContent = "OFF";
      }
    }

    function startQuestionTimer(){
      if(qTimer){ clearInterval(qTimer); qTimer = null; }
      qEndAt = null;

      if(usePerQ.checked){
        const s = clampFloat(perQSec.value, 0.5, 30);
        perQSec.value = s.toFixed(1);
        qEndAt = Date.now() + s * 1000;
        qTimer = setInterval(() => {
          const leftMs = qEndAt - Date.now();
          const left = Math.max(0, Math.ceil(leftMs / 1000));
          qLeftEl.textContent = left + "s";
          if(leftMs <= 0){
            // time out counts as bad, then next
            recordAttempt("timeout", null);
            registerBad(`시간초과! 정답은 ${current.answer}`);
            nextProblem();
          }
        }, 120);
      } else {
        qLeftEl.textContent = "OFF";
      }
    }

    function clampInt(v, min, max){
      const n = parseInt(v, 10);
      if(Number.isNaN(n)) return min;
      return Math.min(max, Math.max(min, n));
    }
    function clampFloat(v, min, max){
      const n = parseFloat(v);
      if(Number.isNaN(n)) return min;
      return Math.min(max, Math.max(min, n));
    }

    function getCurrentLimit(){
      const op = opSelect.value;
      const ladder = ladders[op];
      const lvl = ladder[levelSelect.selectedIndex];
      return lvl.t;
    }

    function loadStats(uid){
      try{
        const raw = localStorage.getItem(`ms_stats_${uid}`);
        return raw ? JSON.parse(raw) : {};
      } catch(e){
        return {};
      }
    }
    function saveStats(uid, data){
      localStorage.setItem(`ms_stats_${uid}`, JSON.stringify(data));
    }
    function saveAttempt(entry){
      if(!currentUserId) return;
      db.collection("attempts").add({
        uid: currentUserId,
        email: currentUserEmail || null,
        nickname: currentNickname || null,
        op: entry.op,
        level: entry.level,
        problem: entry.problem,
        answer: entry.answer,
        userAnswer: entry.userAnswer === undefined ? null : entry.userAnswer,
        result: entry.result,
        time: entry.time,
        limit: entry.limit,
        clientTs: entry.ts,
        serverTs: firebase.firestore.FieldValue.serverTimestamp()
      }).catch(() => {});
    }
    function loadWeak(uid){
      try{
        const raw = localStorage.getItem(`ms_weak_${uid}`);
        return raw ? JSON.parse(raw) : { items: {} };
      } catch(e){
        return { items: {} };
      }
    }
    function saveWeak(uid, data){
      localStorage.setItem(`ms_weak_${uid}`, JSON.stringify(data));
    }
    function syncWeakLimit(op, level, limit){
      if(!currentUserId) return;
      const data = loadWeak(currentUserId);
      const items = data.items || {};
      let changed = false;
      Object.values(items).forEach(item => {
        if(item.op === op && item.level === level){
          item.limit = limit;
          changed = true;
        }
      });
      if(changed) saveWeak(currentUserId, data);
    }

    function normalizeNickname(raw){
      return raw.trim().replace(/\s+/g, "");
    }
    function isValidNickname(nick){
      if(nick.length < 2 || nick.length > 12) return false;
      return /^[A-Za-z0-9가-힣_]+$/.test(nick);
    }
    async function loadNickname(uid){
      try{
        const doc = await db.collection("users").doc(uid).get();
        if(doc.exists && doc.data().nickname){
          currentNickname = doc.data().nickname;
        } else {
          currentNickname = null;
        }
      } catch(e){
        currentNickname = null;
      }
      updateNicknameUI();
    }
    function updateNicknameUI(){
      if(!currentUserId){
        nicknameInput.value = "";
        nicknameInput.disabled = true;
        nicknameSaveBtn.disabled = true;
        nicknameStatus.textContent = "";
        return;
      }
      nicknameInput.disabled = false;
      nicknameSaveBtn.disabled = false;
      if(currentNickname){
        nicknameInput.value = currentNickname;
        nicknameStatus.textContent = `현재 닉네임: ${currentNickname}`;
      } else {
        nicknameInput.value = "";
        nicknameStatus.textContent = "닉네임을 설정해 주세요.";
      }
    }
    async function saveNickname(){
      if(!currentUserId) return;
      const raw = nicknameInput.value;
      const nick = normalizeNickname(raw);
      if(!isValidNickname(nick)){
        nicknameStatus.textContent = "닉네임은 2~12자, 한글/영문/숫자/밑줄만 가능합니다.";
        return;
      }
      if(currentNickname === nick){
        nicknameStatus.textContent = "이미 설정된 닉네임입니다.";
        return;
      }
      nicknameStatus.textContent = "저장 중...";
      const nickKey = nick.toLowerCase();
      const nickRef = db.collection("nicknames").doc(nickKey);
      const userRef = db.collection("users").doc(currentUserId);
      const prevKey = currentNickname ? currentNickname.toLowerCase() : null;
      const prevRef = prevKey ? db.collection("nicknames").doc(prevKey) : null;
      try{
        await db.runTransaction(async (tx) => {
          const nickSnap = await tx.get(nickRef);
          if(nickSnap.exists && nickSnap.data().uid !== currentUserId){
            throw new Error("taken");
          }
          tx.set(nickRef, {
            uid: currentUserId,
            nickname: nick,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          });
          if(prevRef && prevKey !== nickKey){
            const prevSnap = await tx.get(prevRef);
            if(prevSnap.exists && prevSnap.data().uid === currentUserId){
              tx.delete(prevRef);
            }
          }
          tx.set(userRef, {
            nickname: nick,
            email: currentUserEmail || null,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
        });
        currentNickname = nick;
        updateNicknameUI();
        nicknameStatus.textContent = "닉네임이 저장되었습니다.";
      } catch(e){
        nicknameStatus.textContent = "이미 사용 중인 닉네임입니다.";
      }
    }
    function makeWeakId(entry){
      return `${entry.op}|${entry.level}|${entry.problem}|${entry.answer}`;
    }
    function upsertWeakness(entry, reason){
      const data = loadWeak(currentUserId);
      const id = makeWeakId(entry);
      const now = Date.now();
      const item = data.items[id] || {
        id,
        op: entry.op,
        level: entry.level,
        problem: entry.problem,
        answer: entry.answer,
        limit: entry.limit,
        choices: entry.choices || null,
        reasons: { wrong: false, slow: false },
        stage: 0,
        nextAt: now,
        lastResult: entry.result,
        lastTime: entry.time,
        lastTs: entry.ts
      };
      item.limit = entry.limit;
      item.choices = entry.choices || null;
      item.reasons.wrong = item.reasons.wrong || !!reason.wrong;
      item.reasons.slow = item.reasons.slow || !!reason.slow;
      item.stage = 0;
      item.nextAt = now;
      item.lastResult = entry.result;
      item.lastTime = entry.time;
      item.lastTs = entry.ts;
      data.items[id] = item;
      saveWeak(currentUserId, data);
    }

    function recordAttempt(result, userAnswer){
      if(!currentUserId || !current) return;
      const timeSec = qStartAt ? (Date.now() - qStartAt) / 1000 : 0;
      const limitSec = getCurrentLimit();
      const entry = {
        op: opSelect.value,
        level: levelSelect.value,
        problem: current.shownText,
        answer: current.answer,
        userAnswer: userAnswer,
        choices: current.isChoice ? (current.choices || []) : null,
        time: Number(timeSec.toFixed(1)),
        limit: limitSec,
        result: result,
        ts: Date.now()
      };

      const data = loadStats(currentUserId);
      if(!data[entry.op]) data[entry.op] = { wrong: [], slow: [] };
      if(result !== "correct"){
        data[entry.op].wrong.push(entry);
      }
      if(entry.time >= limitSec){
        data[entry.op].slow.push(entry);
      }
      saveStats(currentUserId, data);

      const reason = {
        wrong: result !== "correct",
        slow: entry.time >= limitSec
      };
      if(reason.wrong || reason.slow){
        upsertWeakness(entry, reason);
      }
      saveAttempt(entry);
    }

    function genProblem(){
      const op = opSelect.value;
      const ladder = ladders[op];
      const lvl = ladder[levelSelect.selectedIndex];

      let a = 0;
      let b = 0;
      if(op !== "trig"){
        a = randNDigits(lvl.a);
        b = randNDigits(lvl.b);
      }

      // Avoid super-trivial for multi-digit: prevent b=0 in division and multiplication?
      // We'll handle per-op.
      let answer, shown, choices, isChoice;

      if(op === "add"){
        answer = a + b;
        shown = `${a} + ${b}`;
      } else if(op === "sub"){
        // prevent negative: ensure a >= b
        if(a < b){ const t=a; a=b; b=t; }
        answer = a - b;
        shown = `${a} − ${b}`;
      } else if(op === "mul"){
        // optionally avoid 0 too often: if both digits are 1 and 0 appears too much, fine for now
        answer = a * b;
        shown = `${a} × ${b}`;
      } else if(op === "div"){
        // division: must divide evenly. We will create (dividend ÷ divisor) with exact quotient.
        // Given desired digit sizes: a digits = dividend, b digits = divisor
        // Approach: sample divisor (b digits, not 0), sample quotient (>=1),
        // compute dividend = divisor * quotient and ensure digit length matches a.
        const divisorDigits = lvl.b;
        const dividendDigits = lvl.a;

        let divisor, quotient, dividend;
        let tries = 0;
        while(true){
          tries++;
          if(tries > 2000){
            // fallback (shouldn't happen)
            divisor = Math.max(1, randNDigits(divisorDigits));
            quotient = randint(1, 9);
            dividend = divisor * quotient;
            break;
          }

          divisor = randNDigits(divisorDigits);
          if(divisor === 0) continue;

          // choose quotient range to get dividend digits roughly right
          // dividend ≈ divisor * quotient should have dividendDigits digits
          const minDividend = dividendDigits === 1 ? 0 : pow10(dividendDigits - 1);
          const maxDividend = pow10(dividendDigits) - 1;

          // quotient bounds: ceil(minDividend/divisor) .. floor(maxDividend/divisor)
          const qMin = Math.ceil(minDividend / divisor);
          const qMax = Math.floor(maxDividend / divisor);

          const qLo = Math.max(1, qMin);
          const qHi = Math.max(1, qMax);
          if(qLo > qHi) continue;

          quotient = randint(qLo, qHi);
          dividend = divisor * quotient;

          // ensure exact digit length match (especially for 2-digit min could be 10)
          if(dividend < minDividend || dividend > maxDividend) continue;

          // pass
          break;
        }
        a = dividend;
        b = divisor;
        answer = quotient;
        shown = `${a} ÷ ${b}`;
      } else if(op === "trig"){
        const funcs = ["sin", "cos", "tan"];
        const func = funcs[randint(0, funcs.length - 1)];
        const useRad = Math.random() < 0.5;
        const degAngles = [0, 30, 45, 60, 90];
        const radAngles = ["π/6", "π/4", "π/3", "π/2"];
        let angleText = "";
        let key = "";
        if(useRad){
          let candidates = radAngles.slice();
          if(func === "tan"){ candidates = candidates.filter(a => a !== "π/2"); }
          const angle = candidates[randint(0, candidates.length - 1)];
          angleText = angle;
          key = `rad:${angle}`;
        } else {
          let candidates = degAngles.slice();
          if(func === "tan"){ candidates = candidates.filter(a => a !== 90); }
          const angle = candidates[randint(0, candidates.length - 1)];
          angleText = `${angle}°`;
          key = `deg:${angle}`;
        }
        answer = TRIG_TABLE[key][func];
        shown = `${func} ${angleText}`;
        choices = func === "tan" ? TRIG_CHOICES.tan : TRIG_CHOICES.sincos;
        isChoice = true;
      }

      return { a, b, op, answer, shownText: shown, choices, isChoice };
    }

    function renderProblem(){
      problemBox.innerHTML = formatMathHTML(current.shownText);
      answerInput.value = "";
      statusEl.className = "status";
      statusEl.textContent = "";
      if(current.isChoice){
        choiceBox.style.display = "grid";
        renderChoices(current.choices || []);
        answerInput.disabled = true;
        submitBtn.disabled = true;
        answerRow.style.display = "none";
        kbd.style.display = "none";
        // no help text
      } else {
        choiceBox.style.display = "none";
        answerInput.disabled = false;
        submitBtn.disabled = false;
        answerRow.style.display = "flex";
        kbd.style.display = "grid";
        // no help text
      }
      qStartAt = Date.now();
      startQuestionTimer();
    }

    function registerOk(msg){
      okCnt++;
      okCntEl.textContent = okCnt;
      statusEl.className = "status ok";
      statusEl.textContent = msg;
    }
    function registerBad(msg){
      badCnt++;
      badCntEl.textContent = badCnt;
      statusEl.className = "status bad";
      statusEl.textContent = msg;
    }

    function nextProblem(){
      if(!running) return;
      current = genProblem();
      renderProblem();
      answerInput.focus();
    }

    function endRun(msg){
      setUIRunning(false);
      running = false;
      clearTimers();
      setIdleProblem();
      statusEl.className = "status";
      statusEl.textContent = msg || "";
      answerInput.value = "";
    }

    function renderChoices(choices){
      choiceBox.innerHTML = "";
      choices.forEach(val => {
        const btn = document.createElement("button");
        btn.className = "choice-btn";
        btn.type = "button";
        btn.innerHTML = formatMathHTML(val);
        btn.addEventListener("click", () => submitChoice(val));
        choiceBox.appendChild(btn);
      });
    }

    function submitChoice(val){
      if(!running || !current || !current.isChoice) return;
      if(val === current.answer){
        recordAttempt("correct", val);
        registerOk("정답!");
      } else {
        recordAttempt("wrong", val);
        registerBad(`오답! 정답은 ${current.answer}`);
      }
      nextProblem();
    }

    function submitAnswer(){
      if(!running || !current) return;
      if(current.isChoice) return;

      const raw = answerInput.value.trim();
      if(raw === "") return;

      const userAns = parseInt(raw, 10);
      if(Number.isNaN(userAns)) return;

      if(userAns === current.answer){
        recordAttempt("correct", userAns);
        registerOk("정답!");
      } else {
        recordAttempt("wrong", userAns);
        registerBad(`오답! 정답은 ${current.answer}`);
      }
      nextProblem();
    }

    function autoSubmitIfCorrect(){
      if(!running || !current || current.isChoice) return;
      const raw = answerInput.value.trim();
      if(raw === "") return;
      const userAns = parseInt(raw, 10);
      if(Number.isNaN(userAns)) return;
      if(userAns === current.answer){
        submitAnswer();
      }
    }

    // ====== UI init ======
    function populateLevelOptions(){
      levelSelect.innerHTML = "";
      const op = opSelect.value;
      const ladder = ladders[op];
      ladder.forEach((lvl, i) => {
        const opt = document.createElement("option");
        opt.value = lvl.name;
        opt.textContent = `${i+1}. ${lvl.name}`;
        levelSelect.appendChild(opt);
      });
      levelSelect.selectedIndex = 0;
      updateRuleUI();
    }

    // ====== Firebase Auth (Google) ======
    const firebaseConfig = {
      apiKey: "AIzaSyA_UHGO2HW07NLlNlKyejzHOpCZPwm30TA",
      authDomain: "math-sprint-9c129.firebaseapp.com",
      projectId: "math-sprint-9c129",
      storageBucket: "math-sprint-9c129.firebasestorage.app",
      messagingSenderId: "358959824417",
      appId: "1:358959824417:web:21c328839c758c77b16d60",
      measurementId: "G-WTT3YC0BTW"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const provider = new firebase.auth.GoogleAuthProvider();

    function isMobile(){
      return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
    }

    // ====== Events ======
    const authReady = auth
      .setPersistence(firebase.auth.Auth.Persistence.LOCAL)
      .then(() => auth.getRedirectResult())
      .catch(() => null);

    googleLoginBtn.addEventListener("click", async () => {
      try{
        if(isMobile()){
          await auth.signInWithRedirect(provider);
        } else {
          await auth.signInWithPopup(provider);
        }
      } catch(e){
        authStatus.textContent = "로그인 중 오류가 발생했습니다.";
      }
    });

    logoutBtn.addEventListener("click", async () => {
      await auth.signOut();
    });

    authReady.finally(() => {
      auth.onAuthStateChanged((user) => {
        currentUserId = user ? user.uid : null;
        currentUserEmail = user ? user.email : null;
        updateAuthUI(user);
        if(user){
          loadNickname(user.uid);
        } else {
          currentNickname = null;
          updateNicknameUI();
        }
      });
    });

    opSelect.addEventListener("change", () => {
      populateLevelOptions();
    });
    levelSelect.addEventListener("change", updateRuleUI);

    usePerQ.addEventListener("change", () => {
      perQSec.disabled = running || !usePerQ.checked;
      if(usePerQ.checked){
        updateRuleUI();
      }
      updateSettingUI();
    });
    useSet.addEventListener("change", () => {
      setSec.disabled = running || !useSet.checked;
      updateSettingUI();
    });
    perQSec.addEventListener("input", () => {
      if(usePerQ.checked){
        const v = clampFloat(perQSec.value, 0.5, 30);
        perQSec.value = v.toFixed(1);
        syncWeakLimit(opSelect.value, levelSelect.value, v);
      }
      updateSettingUI();
    });
    setSec.addEventListener("input", updateSettingUI);
    nicknameSaveBtn.addEventListener("click", saveNickname);

    startBtn.addEventListener("click", () => {
      if(isLocked){
        statusEl.className = "status bad";
        statusEl.textContent = "로그인 후 이용할 수 있습니다.";
        return;
      }
      okCnt = 0; badCnt = 0;
      okCntEl.textContent = "0";
      badCntEl.textContent = "0";

      setUIRunning(true);
      running = true;
      startSetTimers();
      nextProblem();
    });

    stopBtn.addEventListener("click", () => {
      endRun("중지되었습니다.");
    });

    submitBtn.addEventListener("click", submitAnswer);
    answerInput.addEventListener("input", autoSubmitIfCorrect);

    // keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if(!running) return;
      if(e.key === "Enter"){
        e.preventDefault();
        submitAnswer();
      }
      // allow minus? not needed (we generate non-negative results)
    });

    // On-screen keypad
    document.querySelectorAll(".kbtn").forEach(btn => {
      btn.addEventListener("click", () => {
        if(answerInput.disabled) return;
        const k = btn.getAttribute("data-k");
        const act = btn.getAttribute("data-act");
        if(k !== null){
          answerInput.value += k;
          answerInput.focus();
        } else if(act === "del"){
          answerInput.value = answerInput.value.slice(0, -1);
          answerInput.focus();
        } else if(act === "enter"){
          submitAnswer();
        }
      });
    });

    // init
    populateLevelOptions();
    updateSettingUI();
    setIdleProblem();
    usePerQ.checked = true;
    usePerQ.disabled = false;
    perQSec.disabled = !usePerQ.checked;
  </script>
</body>
</html>
